#pragma once
#include <flow/ProductionPolicy.h>
#include <memory>
#include <optional>
#include <vector>
#include <nstd/types/any.hpp>

namespace pt::flow {
/**
 * A single processing unit in the `flow` framework.
 * It's connected to other `Flow` objects like a linked list,
 * but can have more than 1 flow object next in line.
 *
 * Data gets consumed by it, processed and changed (type, value or both)
 * Then it gets produced to the next `Flow` objects in line.
 *
 * The produced data gets spread to the next nodes in different ways based on the given
 * ProductionPolicy
 * @ref pt::flow::ProductionPolicy
 */
class Flow {
public:
    using input_type = void;
    using output_type = void;

    /**
     * Fanout by default, assumes there is a single output to be copied.
     * @param policy The way the flow object will produce the items to the next modules.
     */
    explicit Flow(const ProductionPolicy policy = ProductionPolicy::Fanout) : policy(policy) {}

    virtual ~Flow() = default;

    /**
     * Adds a flow object to the next nodes.
     * @param next The next module
     */
    void add_consumer(std::shared_ptr<Flow> next) {
        size_t id = next->register_producer(next);
        next_nodes.emplace_back(next, id);
    }


    virtual void execute(nstd::any in = {}, size_t producer_id = 0) {
        auto output = process_any(std::move(in), producer_id);

        const std::type_info& out_type = output.type();
        if (!output.has_value() || out_type == typeid(std::nullopt_t)) {
            return;
        }

        produce(std::move(output));
    }

protected:
    /**
     * Produces the output to the next flow objects based on the production policy.
     * @param output The non-typed output to produce to the next flow objects.
     */
    void produce(nstd::any output) {
        switch (policy) {
            case ProductionPolicy::RoundRobin:
                round_robin_produce(std::move(output));
                break;
            case ProductionPolicy::Fanout:
                for (size_t i = 0; i < next_nodes.size() - 1; ++i) {
                    auto& [next, id] = next_nodes[i];
                    next->execute(output, id);
                }

                auto& [last, id] = next_nodes.at(next_nodes.size() - 1);
                last->execute(std::move(output), id);
                break;
        }
    }

    /**
     * Consumer override point (e.g. Aggregator)
     * @return The ID generated by the overrider
     */
    virtual size_t register_producer(std::shared_ptr<Flow>) {
        return 0;
    }

    virtual nstd::any process_any(nstd::any, size_t producer_id) = 0;

    /**
     * Consumer override point (e.g. FlowWithOutput)
     */
    virtual void round_robin_produce(nstd::any output) {  // cpp:S1238
        throw std::runtime_error("Round Robin not implemented for this flow object.");
    }

    /// (next node, producer_id for that consumer)
    std::vector<std::pair<std::shared_ptr<Flow>, size_t>> next_nodes;

private:
    ProductionPolicy policy;
};

/**
 * Manual connection (for branching, fanout...)
 * @param from The module to connect from
 * @param to The module to connect to
 */
static void connect(const std::shared_ptr<Flow>& from, const std::shared_ptr<Flow>& to) {
    from->add_consumer(to);
}
}  // namespace pt::flow